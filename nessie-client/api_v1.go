/*
Nessie API

Transactional Catalog for Data Lakes  * Git-inspired data version control * Cross-table transactions and visibility * Works with Apache Iceberg tables

API version: 0.102.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// V1APIService V1API service
type V1APIService service

type ApiAssignReferenceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	referenceName string
	referenceType string
	expectedHash *string
	reference2 *Reference2
}

// Expected previous hash of reference
func (r ApiAssignReferenceRequest) ExpectedHash(expectedHash string) ApiAssignReferenceRequest {
	r.expectedHash = &expectedHash
	return r
}

// Reference hash to which &#39;referenceName&#39; shall be assigned to. This must be either a &#39;Transaction&#39;, &#39;Branch&#39; or &#39;Tag&#39; via which the hash is visible to the caller.
func (r ApiAssignReferenceRequest) Reference2(reference2 Reference2) ApiAssignReferenceRequest {
	r.reference2 = &reference2
	return r
}

func (r ApiAssignReferenceRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignReferenceExecute(r)
}

/*
AssignReference Set a named reference to a specific hash via a named-reference.

This operation takes the name of the named reference to reassign and the hash and the name of a named-reference via which the caller has access to that hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param referenceName Reference name to reassign
 @param referenceType Reference type to reassign
 @return ApiAssignReferenceRequest
*/
func (a *V1APIService) AssignReference(ctx context.Context, referenceName string, referenceType string) ApiAssignReferenceRequest {
	return ApiAssignReferenceRequest{
		ApiService: a,
		ctx: ctx,
		referenceName: referenceName,
		referenceType: referenceType,
	}
}

// Execute executes the request
func (a *V1APIService) AssignReferenceExecute(r ApiAssignReferenceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.AssignReference")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/{referenceType}/{referenceName}"
	localVarPath = strings.Replace(localVarPath, "{"+"referenceName"+"}", url.PathEscape(parameterValueToString(r.referenceName, "referenceName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"referenceType"+"}", url.PathEscape(parameterValueToString(r.referenceType, "referenceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.expectedHash == nil {
		return nil, reportError("expectedHash is required and must be specified")
	}
	if r.reference2 == nil {
		return nil, reportError("reference2 is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "expectedHash", r.expectedHash, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reference2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommitMultipleOperationsRequest struct {
	ctx context.Context
	ApiService *V1APIService
	branchName string
	operations1 *Operations1
	expectedHash *string
}

// Operations
func (r ApiCommitMultipleOperationsRequest) Operations1(operations1 Operations1) ApiCommitMultipleOperationsRequest {
	r.operations1 = &operations1
	return r
}

// Expected hash of branch.
func (r ApiCommitMultipleOperationsRequest) ExpectedHash(expectedHash string) ApiCommitMultipleOperationsRequest {
	r.expectedHash = &expectedHash
	return r
}

func (r ApiCommitMultipleOperationsRequest) Execute() (*Branch1, *http.Response, error) {
	return r.ApiService.CommitMultipleOperationsExecute(r)
}

/*
CommitMultipleOperations Commit multiple operations against the given branch expecting that branch to have the given hash as its latest commit. The hash in the successful response contains the hash of the commit that contains the operations of the invocation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param branchName Branch to change, defaults to default branch.
 @return ApiCommitMultipleOperationsRequest
*/
func (a *V1APIService) CommitMultipleOperations(ctx context.Context, branchName string) ApiCommitMultipleOperationsRequest {
	return ApiCommitMultipleOperationsRequest{
		ApiService: a,
		ctx: ctx,
		branchName: branchName,
	}
}

// Execute executes the request
//  @return Branch1
func (a *V1APIService) CommitMultipleOperationsExecute(r ApiCommitMultipleOperationsRequest) (*Branch1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Branch1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.CommitMultipleOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/branch/{branchName}/commit"
	localVarPath = strings.Replace(localVarPath, "{"+"branchName"+"}", url.PathEscape(parameterValueToString(r.branchName, "branchName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.operations1 == nil {
		return localVarReturnValue, nil, reportError("operations1 is required and must be specified")
	}

	if r.expectedHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedHash", r.expectedHash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operations1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNamespaceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	name Content1AnyOf2
	ref string
	content1AnyOf2 *Content1AnyOf2
	hashOnRef *string
}

func (r ApiCreateNamespaceRequest) Content1AnyOf2(content1AnyOf2 Content1AnyOf2) ApiCreateNamespaceRequest {
	r.content1AnyOf2 = &content1AnyOf2
	return r
}

// a particular hash on the given ref
func (r ApiCreateNamespaceRequest) HashOnRef(hashOnRef string) ApiCreateNamespaceRequest {
	r.hashOnRef = &hashOnRef
	return r
}

func (r ApiCreateNamespaceRequest) Execute() (*Content1AnyOf2, *http.Response, error) {
	return r.ApiService.CreateNamespaceExecute(r)
}

/*
CreateNamespace Creates a Namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the name of the namespace
 @param ref name of ref to fetch
 @return ApiCreateNamespaceRequest
*/
func (a *V1APIService) CreateNamespace(ctx context.Context, name Content1AnyOf2, ref string) ApiCreateNamespaceRequest {
	return ApiCreateNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		ref: ref,
	}
}

// Execute executes the request
//  @return Content1AnyOf2
func (a *V1APIService) CreateNamespaceExecute(r ApiCreateNamespaceRequest) (*Content1AnyOf2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Content1AnyOf2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.CreateNamespace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/namespaces/namespace/{ref}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.content1AnyOf2 == nil {
		return localVarReturnValue, nil, reportError("content1AnyOf2 is required and must be specified")
	}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.content1AnyOf2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReferenceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	reference2 *Reference2
	sourceRefName *string
}

// Reference to create.
func (r ApiCreateReferenceRequest) Reference2(reference2 Reference2) ApiCreateReferenceRequest {
	r.reference2 = &reference2
	return r
}

// Source named reference
func (r ApiCreateReferenceRequest) SourceRefName(sourceRefName string) ApiCreateReferenceRequest {
	r.sourceRefName = &sourceRefName
	return r
}

func (r ApiCreateReferenceRequest) Execute() (*Reference1, *http.Response, error) {
	return r.ApiService.CreateReferenceExecute(r)
}

/*
CreateReference Create a new reference

The type of 'refObj', which can be either a 'Branch' or 'Tag', determines the type of the reference to be created.

'Reference.name' defines the the name of the reference to be created,'Reference.hash' is the hash of the created reference, the HEAD of the created reference. 'sourceRefName' is the name of the reference which contains 'Reference.hash', and must be present if 'Reference.hash' is present.

Specifying no 'Reference.hash' means that the new reference will be created "at the beginning of time".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReferenceRequest
*/
func (a *V1APIService) CreateReference(ctx context.Context) ApiCreateReferenceRequest {
	return ApiCreateReferenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Reference1
func (a *V1APIService) CreateReferenceExecute(r ApiCreateReferenceRequest) (*Reference1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reference1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.CreateReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/tree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reference2 == nil {
		return localVarReturnValue, nil, reportError("reference2 is required and must be specified")
	}

	if r.sourceRefName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceRefName", r.sourceRefName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reference2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNamespaceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	name Content1AnyOf2
	ref string
	hashOnRef *string
}

// a particular hash on the given ref
func (r ApiDeleteNamespaceRequest) HashOnRef(hashOnRef string) ApiDeleteNamespaceRequest {
	r.hashOnRef = &hashOnRef
	return r
}

func (r ApiDeleteNamespaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNamespaceExecute(r)
}

/*
DeleteNamespace Deletes a Namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the name of the namespace
 @param ref name of ref to fetch
 @return ApiDeleteNamespaceRequest
*/
func (a *V1APIService) DeleteNamespace(ctx context.Context, name Content1AnyOf2, ref string) ApiDeleteNamespaceRequest {
	return ApiDeleteNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		ref: ref,
	}
}

// Execute executes the request
func (a *V1APIService) DeleteNamespaceExecute(r ApiDeleteNamespaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.DeleteNamespace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/namespaces/namespace/{ref}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteReferenceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	referenceName string
	referenceType string
	expectedHash *string
}

// Expected hash of tag
func (r ApiDeleteReferenceRequest) ExpectedHash(expectedHash string) ApiDeleteReferenceRequest {
	r.expectedHash = &expectedHash
	return r
}

func (r ApiDeleteReferenceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReferenceExecute(r)
}

/*
DeleteReference Delete a reference endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param referenceName Reference name to delete
 @param referenceType Reference type to delete
 @return ApiDeleteReferenceRequest
*/
func (a *V1APIService) DeleteReference(ctx context.Context, referenceName string, referenceType string) ApiDeleteReferenceRequest {
	return ApiDeleteReferenceRequest{
		ApiService: a,
		ctx: ctx,
		referenceName: referenceName,
		referenceType: referenceType,
	}
}

// Execute executes the request
func (a *V1APIService) DeleteReferenceExecute(r ApiDeleteReferenceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.DeleteReference")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/{referenceType}/{referenceName}"
	localVarPath = strings.Replace(localVarPath, "{"+"referenceName"+"}", url.PathEscape(parameterValueToString(r.referenceName, "referenceName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"referenceType"+"}", url.PathEscape(parameterValueToString(r.referenceType, "referenceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.expectedHash == nil {
		return nil, reportError("expectedHash is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "expectedHash", r.expectedHash, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllReferencesRequest struct {
	ctx context.Context
	ApiService *V1APIService
	fetch *string
	filter *string
	maxRecords *int32
	pageToken *string
}

// Specify how much information to be returned. Will fetch additional metadata for references if set to &#39;ALL&#39;.  A returned Branch instance will have the following information:  - numCommitsAhead (number of commits ahead of the default branch)  - numCommitsBehind (number of commits behind the default branch)  - commitMetaOfHEAD (the commit metadata of the HEAD commit)  - commonAncestorHash (the hash of the common ancestor in relation to the default branch).  - numTotalCommits (the total number of commits in this reference).  A returned Tag instance will only contain the &#39;commitMetaOfHEAD&#39; and &#39;numTotalCommits&#39; fields.  Note that computing &amp; fetching additional metadata might be computationally expensive on the server-side, so this flag should be used with care.
func (r ApiGetAllReferencesRequest) Fetch(fetch string) ApiGetAllReferencesRequest {
	r.fetch = &fetch
	return r
}

// A Common Expression Language (CEL) expression. An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md. Usable variables within the expression are:  - ref (Reference) describes the reference, with fields name (String), hash (String), metadata (ReferenceMetadata)  - metadata (ReferenceMetadata) shortcut to ref.metadata, never null, but possibly empty  - commit (CommitMeta) - shortcut to ref.metadata.commitMetaOfHEAD, never null, but possibly empty  - refType (String) - the reference type, either BRANCH or TAG  Note that the expression can only test attributes metadata and commit, if &#39;fetchOption&#39; is set to &#39;ALL&#39;.
func (r ApiGetAllReferencesRequest) Filter(filter string) ApiGetAllReferencesRequest {
	r.filter = &filter
	return r
}

// maximum number of entries to return, just a hint for the server
func (r ApiGetAllReferencesRequest) MaxRecords(maxRecords int32) ApiGetAllReferencesRequest {
	r.maxRecords = &maxRecords
	return r
}

// paging continuation token, as returned in the previous value of the field &#39;token&#39; in the corresponding &#39;EntriesResponse&#39; or &#39;LogResponse&#39; or &#39;ReferencesResponse&#39; or &#39;RefLogResponse&#39;.
func (r ApiGetAllReferencesRequest) PageToken(pageToken string) ApiGetAllReferencesRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiGetAllReferencesRequest) Execute() (*GetAllReferences200Response, *http.Response, error) {
	return r.ApiService.GetAllReferencesExecute(r)
}

/*
GetAllReferences Get all references

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllReferencesRequest
*/
func (a *V1APIService) GetAllReferences(ctx context.Context) ApiGetAllReferencesRequest {
	return ApiGetAllReferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllReferences200Response
func (a *V1APIService) GetAllReferencesExecute(r ApiGetAllReferencesRequest) (*GetAllReferences200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllReferences200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetAllReferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch", r.fetch, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.maxRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRecords", r.maxRecords, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommitLogRequest struct {
	ctx context.Context
	ApiService *V1APIService
	ref string
	endHash *string
	fetch *string
	filter *string
	maxRecords *int32
	pageToken *string
	startHash *string
}

// Hash on the given ref to end at (in chronological sense), the &#39;near&#39; end of the commit log, returned &#39;early&#39; in the result.
func (r ApiGetCommitLogRequest) EndHash(endHash string) ApiGetCommitLogRequest {
	r.endHash = &endHash
	return r
}

// Specify how much information to be returned. Will fetch additional metadata such as parent commit hash and operations in a commit, for each commit if set to &#39;ALL&#39;.
func (r ApiGetCommitLogRequest) Fetch(fetch string) ApiGetCommitLogRequest {
	r.fetch = &fetch
	return r
}

// A Common Expression Language (CEL) expression. An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  Usable variables within the expression are:  - &#39;commit&#39; with fields &#39;author&#39; (string), &#39;committer&#39; (string), &#39;commitTime&#39; (timestamp), &#39;hash&#39; (string), &#39;,message&#39; (string), &#39;properties&#39; (map)  - &#39;operations&#39; (list), each operation has the fields &#39;type&#39; (string, either &#39;PUT&#39; or &#39;DELETE&#39;), &#39;key&#39; (string, namespace + table name), &#39;keyElements&#39; (list of strings), &#39;namespace&#39; (string), &#39;namespaceElements&#39; (list of strings) and &#39;name&#39; (string, the \&quot;simple\&quot; table name)  Note that the expression can only test against &#39;operations&#39;, if &#39;fetch&#39; is set to &#39;ALL&#39;.  Hint: when filtering commits, you can determine whether commits are \&quot;missing\&quot; (filtered) by checking whether &#39;LogEntry.parentCommitHash&#39; is different from the hash of the previous commit in the log response.
func (r ApiGetCommitLogRequest) Filter(filter string) ApiGetCommitLogRequest {
	r.filter = &filter
	return r
}

// maximum number of entries to return, just a hint for the server
func (r ApiGetCommitLogRequest) MaxRecords(maxRecords int32) ApiGetCommitLogRequest {
	r.maxRecords = &maxRecords
	return r
}

// paging continuation token, as returned in the previous value of the field &#39;token&#39; in the corresponding &#39;EntriesResponse&#39; or &#39;LogResponse&#39; or &#39;ReferencesResponse&#39; or &#39;RefLogResponse&#39;.
func (r ApiGetCommitLogRequest) PageToken(pageToken string) ApiGetCommitLogRequest {
	r.pageToken = &pageToken
	return r
}

// Hash on the given ref to start from (in chronological sense), the &#39;far&#39; end of the commit log, returned &#39;late&#39; in the result.
func (r ApiGetCommitLogRequest) StartHash(startHash string) ApiGetCommitLogRequest {
	r.startHash = &startHash
	return r
}

func (r ApiGetCommitLogRequest) Execute() (*LogResponse1, *http.Response, error) {
	return r.ApiService.GetCommitLogExecute(r)
}

/*
GetCommitLog Get commit log for a reference

Retrieve the commit log for a ref, potentially truncated by the backend.

Retrieves up to 'maxRecords' commit-log-entries starting at the HEAD of the given named reference (tag or branch) or the given hash. The backend may respect the given 'max' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.

To implement paging, check 'hasMore' in the response and, if 'true', pass the value returned as 'token' in the next invocation as the 'pageToken' parameter.

The content and meaning of the returned 'token' is "private" to the implementation,treat is as an opaque value.

It is wrong to assume that invoking this method with a very high 'maxRecords' value will return all commit log entries.

The 'filter' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL).
An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ref ref to show log from
 @return ApiGetCommitLogRequest
*/
func (a *V1APIService) GetCommitLog(ctx context.Context, ref string) ApiGetCommitLogRequest {
	return ApiGetCommitLogRequest{
		ApiService: a,
		ctx: ctx,
		ref: ref,
	}
}

// Execute executes the request
//  @return LogResponse1
func (a *V1APIService) GetCommitLogExecute(r ApiGetCommitLogRequest) (*LogResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetCommitLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/tree/{ref}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.endHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endHash", r.endHash, "form", "")
	}
	if r.fetch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch", r.fetch, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.maxRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRecords", r.maxRecords, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "form", "")
	}
	if r.startHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startHash", r.startHash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigRequest struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r ApiGetConfigRequest) Execute() (*NessieConfiguration1, *http.Response, error) {
	return r.ApiService.GetConfigExecute(r)
}

/*
GetConfig List all configuration settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigRequest
*/
func (a *V1APIService) GetConfig(ctx context.Context) ApiGetConfigRequest {
	return ApiGetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NessieConfiguration1
func (a *V1APIService) GetConfigExecute(r ApiGetConfigRequest) (*NessieConfiguration1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NessieConfiguration1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v NessieConfiguration1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContentRequest struct {
	ctx context.Context
	ApiService *V1APIService
	key string
	hashOnRef *string
	ref *string
}

// a particular hash on the given ref
func (r ApiGetContentRequest) HashOnRef(hashOnRef string) ApiGetContentRequest {
	r.hashOnRef = &hashOnRef
	return r
}

// Reference to use. Defaults to default branch if not provided.
func (r ApiGetContentRequest) Ref(ref string) ApiGetContentRequest {
	r.ref = &ref
	return r
}

func (r ApiGetContentRequest) Execute() (*Content1, *http.Response, error) {
	return r.ApiService.GetContentExecute(r)
}

/*
GetContent Get object content associated with a key.

This operation returns the content-value for a content-key in a named-reference (a branch or tag).

If the table-metadata is tracked globally (Iceberg), Nessie returns a 'Content' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-id, schema-id, partition-spec-id, default-sort-order-id).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key object name to search for
 @return ApiGetContentRequest
*/
func (a *V1APIService) GetContent(ctx context.Context, key string) ApiGetContentRequest {
	return ApiGetContentRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return Content1
func (a *V1APIService) GetContentExecute(r ApiGetContentRequest) (*Content1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Content1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/contents/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultBranchRequest struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r ApiGetDefaultBranchRequest) Execute() (*Branch1, *http.Response, error) {
	return r.ApiService.GetDefaultBranchExecute(r)
}

/*
GetDefaultBranch Get default branch for commits and reads

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDefaultBranchRequest
*/
func (a *V1APIService) GetDefaultBranch(ctx context.Context) ApiGetDefaultBranchRequest {
	return ApiGetDefaultBranchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Branch1
func (a *V1APIService) GetDefaultBranchExecute(r ApiGetDefaultBranchRequest) (*Branch1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Branch1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetDefaultBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/tree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiffRequest struct {
	ctx context.Context
	ApiService *V1APIService
	fromRefWithHash string
	toRefWithHash string
}

func (r ApiGetDiffRequest) Execute() (*DiffResponse1, *http.Response, error) {
	return r.ApiService.GetDiffExecute(r)
}

/*
GetDiff Get a diff for two given references

The URL pattern is basically 'from' and 'to' separated by '...' (three dots). 'from' and 'to' must start with a reference name, optionally followed by hash on that reference, the hash prefixed with the'*' character.

Examples: 
diffs/main...myBranch
diffs/main...myBranch\*1234567890123456
diffs/main\*1234567890123456...myBranch
diffs/main\*1234567890123456...myBranch\*1234567890123456


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromRefWithHash The 'from' reference (and optional hash) to start the diff from
 @param toRefWithHash The 'to' reference (and optional hash) to end the diff at.
 @return ApiGetDiffRequest
*/
func (a *V1APIService) GetDiff(ctx context.Context, fromRefWithHash string, toRefWithHash string) ApiGetDiffRequest {
	return ApiGetDiffRequest{
		ApiService: a,
		ctx: ctx,
		fromRefWithHash: fromRefWithHash,
		toRefWithHash: toRefWithHash,
	}
}

// Execute executes the request
//  @return DiffResponse1
func (a *V1APIService) GetDiffExecute(r ApiGetDiffRequest) (*DiffResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiffResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetDiff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diffs/{fromRefWithHash}...{toRefWithHash}"
	localVarPath = strings.Replace(localVarPath, "{"+"fromRefWithHash"+"}", url.PathEscape(parameterValueToString(r.fromRefWithHash, "fromRefWithHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"toRefWithHash"+"}", url.PathEscape(parameterValueToString(r.toRefWithHash, "toRefWithHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntriesRequest struct {
	ctx context.Context
	ApiService *V1APIService
	ref string
	filter *string
	hashOnRef *string
	maxRecords *int32
	namespaceDepth *int32
	pageToken *string
}

// A Common Expression Language (CEL) expression. An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md. Usable variables within the expression are &#39;entry.namespace&#39; (string) &amp; &#39;entry.contentType&#39; (string)
func (r ApiGetEntriesRequest) Filter(filter string) ApiGetEntriesRequest {
	r.filter = &filter
	return r
}

// a particular hash on the given ref
func (r ApiGetEntriesRequest) HashOnRef(hashOnRef string) ApiGetEntriesRequest {
	r.hashOnRef = &hashOnRef
	return r
}

// maximum number of entries to return, just a hint for the server
func (r ApiGetEntriesRequest) MaxRecords(maxRecords int32) ApiGetEntriesRequest {
	r.maxRecords = &maxRecords
	return r
}

// If set &gt; 0 will filter the results to only return namespaces/tables to the depth of namespaceDepth. If not set or &lt;&#x3D;0 has no effect Setting this parameter &gt; 0 will turn off paging.
func (r ApiGetEntriesRequest) NamespaceDepth(namespaceDepth int32) ApiGetEntriesRequest {
	r.namespaceDepth = &namespaceDepth
	return r
}

// paging continuation token, as returned in the previous value of the field &#39;token&#39; in the corresponding &#39;EntriesResponse&#39; or &#39;LogResponse&#39; or &#39;ReferencesResponse&#39; or &#39;RefLogResponse&#39;.
func (r ApiGetEntriesRequest) PageToken(pageToken string) ApiGetEntriesRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiGetEntriesRequest) Execute() (*GetEntries200Response, *http.Response, error) {
	return r.ApiService.GetEntriesExecute(r)
}

/*
GetEntries Fetch all entries for a given reference

Retrieves objects for a ref, potentially truncated by the backend.

Retrieves up to 'maxRecords' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given 'max' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.

To implement paging, check 'hasMore' in the response and, if 'true', pass the value returned as 'token' in the next invocation as the 'pageToken' parameter.

The content and meaning of the returned 'token' is "private" to the implementation,treat is as an opaque value.

It is wrong to assume that invoking this method with a very high 'maxRecords' value will return all commit log entries.

The 'filter' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL).
An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.

The 'namespaceDepth' parameter returns only the ContentKey components up to the depth of 'namespaceDepth'.
For example they key 'a.b.c.d' with a depth of 3 will return 'a.b.c'. The operation is guaranteed to not return 
duplicates and therefore will never page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ref name of ref to fetch from
 @return ApiGetEntriesRequest
*/
func (a *V1APIService) GetEntries(ctx context.Context, ref string) ApiGetEntriesRequest {
	return ApiGetEntriesRequest{
		ApiService: a,
		ctx: ctx,
		ref: ref,
	}
}

// Execute executes the request
//  @return GetEntries200Response
func (a *V1APIService) GetEntriesExecute(r ApiGetEntriesRequest) (*GetEntries200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEntries200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/tree/{ref}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	if r.maxRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRecords", r.maxRecords, "form", "")
	}
	if r.namespaceDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespaceDepth", r.namespaceDepth, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetEntries200Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMultipleContentsRequest struct {
	ctx context.Context
	ApiService *V1APIService
	getMultipleContentsRequest1 *GetMultipleContentsRequest1
	hashOnRef *string
	ref *string
}

// Keys to retrieve.
func (r ApiGetMultipleContentsRequest) GetMultipleContentsRequest1(getMultipleContentsRequest1 GetMultipleContentsRequest1) ApiGetMultipleContentsRequest {
	r.getMultipleContentsRequest1 = &getMultipleContentsRequest1
	return r
}

// a particular hash on the given ref
func (r ApiGetMultipleContentsRequest) HashOnRef(hashOnRef string) ApiGetMultipleContentsRequest {
	r.hashOnRef = &hashOnRef
	return r
}

// Reference to use. Defaults to default branch if not provided.
func (r ApiGetMultipleContentsRequest) Ref(ref string) ApiGetMultipleContentsRequest {
	r.ref = &ref
	return r
}

func (r ApiGetMultipleContentsRequest) Execute() (*GetMultipleContentsResponse1, *http.Response, error) {
	return r.ApiService.GetMultipleContentsExecute(r)
}

/*
GetMultipleContents Get multiple objects' content.

Similar to 'getContent', but takes multiple 'ContentKey's and returns the content-values for the one or more content-keys in a named-reference (a branch or tag).

If the table-metadata is tracked globally (Iceberg), Nessie returns a 'Content' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-ID,schema-ID, partition-spec-ID, default-sort-order-ID).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMultipleContentsRequest
*/
func (a *V1APIService) GetMultipleContents(ctx context.Context) ApiGetMultipleContentsRequest {
	return ApiGetMultipleContentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMultipleContentsResponse1
func (a *V1APIService) GetMultipleContentsExecute(r ApiGetMultipleContentsRequest) (*GetMultipleContentsResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMultipleContentsResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetMultipleContents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/contents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getMultipleContentsRequest1 == nil {
		return localVarReturnValue, nil, reportError("getMultipleContentsRequest1 is required and must be specified")
	}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getMultipleContentsRequest1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceRequest struct {
	ctx context.Context
	ApiService *V1APIService
	name Content1AnyOf2
	ref string
	hashOnRef *string
}

// a particular hash on the given ref
func (r ApiGetNamespaceRequest) HashOnRef(hashOnRef string) ApiGetNamespaceRequest {
	r.hashOnRef = &hashOnRef
	return r
}

func (r ApiGetNamespaceRequest) Execute() (*Content1AnyOf2, *http.Response, error) {
	return r.ApiService.GetNamespaceExecute(r)
}

/*
GetNamespace Retrieves a Namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the name of the namespace
 @param ref name of ref to fetch
 @return ApiGetNamespaceRequest
*/
func (a *V1APIService) GetNamespace(ctx context.Context, name Content1AnyOf2, ref string) ApiGetNamespaceRequest {
	return ApiGetNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		ref: ref,
	}
}

// Execute executes the request
//  @return Content1AnyOf2
func (a *V1APIService) GetNamespaceExecute(r ApiGetNamespaceRequest) (*Content1AnyOf2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Content1AnyOf2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetNamespace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/namespaces/namespace/{ref}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespacesRequest struct {
	ctx context.Context
	ApiService *V1APIService
	ref string
	hashOnRef *string
	name *Content1AnyOf2
}

// a particular hash on the given ref
func (r ApiGetNamespacesRequest) HashOnRef(hashOnRef string) ApiGetNamespacesRequest {
	r.hashOnRef = &hashOnRef
	return r
}

// the name of the namespace
func (r ApiGetNamespacesRequest) Name(name Content1AnyOf2) ApiGetNamespacesRequest {
	r.name = &name
	return r
}

func (r ApiGetNamespacesRequest) Execute() (*GetNamespaces200Response, *http.Response, error) {
	return r.ApiService.GetNamespacesExecute(r)
}

/*
GetNamespaces Method for GetNamespaces

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ref name of ref to fetch
 @return ApiGetNamespacesRequest
*/
func (a *V1APIService) GetNamespaces(ctx context.Context, ref string) ApiGetNamespacesRequest {
	return ApiGetNamespacesRequest{
		ApiService: a,
		ctx: ctx,
		ref: ref,
	}
}

// Execute executes the request
//  @return GetNamespaces200Response
func (a *V1APIService) GetNamespacesExecute(r ApiGetNamespacesRequest) (*GetNamespaces200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNamespaces200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/namespaces/{ref}"
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReferenceByNameRequest struct {
	ctx context.Context
	ApiService *V1APIService
	ref string
	fetch *string
}

// Specify how much information to be returned. Will fetch additional metadata for references if set to &#39;ALL&#39;.  A returned Branch instance will have the following information:  - numCommitsAhead (number of commits ahead of the default branch)  - numCommitsBehind (number of commits behind the default branch)  - commitMetaOfHEAD (the commit metadata of the HEAD commit)  - commonAncestorHash (the hash of the common ancestor in relation to the default branch).  - numTotalCommits (the total number of commits in this reference).  A returned Tag instance will only contain the &#39;commitMetaOfHEAD&#39; and &#39;numTotalCommits&#39; fields.  Note that computing &amp; fetching additional metadata might be computationally expensive on the server-side, so this flag should be used with care.
func (r ApiGetReferenceByNameRequest) Fetch(fetch string) ApiGetReferenceByNameRequest {
	r.fetch = &fetch
	return r
}

func (r ApiGetReferenceByNameRequest) Execute() (*Reference1, *http.Response, error) {
	return r.ApiService.GetReferenceByNameExecute(r)
}

/*
GetReferenceByName Fetch details of a reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ref name of ref to fetch
 @return ApiGetReferenceByNameRequest
*/
func (a *V1APIService) GetReferenceByName(ctx context.Context, ref string) ApiGetReferenceByNameRequest {
	return ApiGetReferenceByNameRequest{
		ApiService: a,
		ctx: ctx,
		ref: ref,
	}
}

// Execute executes the request
//  @return Reference1
func (a *V1APIService) GetReferenceByNameExecute(r ApiGetReferenceByNameRequest) (*Reference1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reference1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.GetReferenceByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/tree/{ref}"
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch", r.fetch, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeRefIntoBranchRequest struct {
	ctx context.Context
	ApiService *V1APIService
	branchName string
	expectedHash *string
	mergeOperation *MergeOperation
}

// Expected current HEAD of &#39;branchName&#39;
func (r ApiMergeRefIntoBranchRequest) ExpectedHash(expectedHash string) ApiMergeRefIntoBranchRequest {
	r.expectedHash = &expectedHash
	return r
}

// Merge operation that defines the source reference name and an optional hash. If &#39;fromHash&#39; is not present, the current &#39;sourceRef&#39;s HEAD will be used.
func (r ApiMergeRefIntoBranchRequest) MergeOperation(mergeOperation MergeOperation) ApiMergeRefIntoBranchRequest {
	r.mergeOperation = &mergeOperation
	return r
}

func (r ApiMergeRefIntoBranchRequest) Execute() (*MergeResponse, *http.Response, error) {
	return r.ApiService.MergeRefIntoBranchExecute(r)
}

/*
MergeRefIntoBranch Merge commits from 'mergeRef' onto 'branchName'.

Merge items from an existing hash in 'mergeRef' into the requested branch. The merge is always a rebase + fast-forward merge and is only completed if the rebase is conflict free. The set of commits added to the branch will be all of those until we arrive at a common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param branchName Branch to merge into
 @return ApiMergeRefIntoBranchRequest
*/
func (a *V1APIService) MergeRefIntoBranch(ctx context.Context, branchName string) ApiMergeRefIntoBranchRequest {
	return ApiMergeRefIntoBranchRequest{
		ApiService: a,
		ctx: ctx,
		branchName: branchName,
	}
}

// Execute executes the request
//  @return MergeResponse
func (a *V1APIService) MergeRefIntoBranchExecute(r ApiMergeRefIntoBranchRequest) (*MergeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.MergeRefIntoBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/branch/{branchName}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"branchName"+"}", url.PathEscape(parameterValueToString(r.branchName, "branchName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.expectedHash == nil {
		return localVarReturnValue, nil, reportError("expectedHash is required and must be specified")
	}
	if r.mergeOperation == nil {
		return localVarReturnValue, nil, reportError("mergeOperation is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "expectedHash", r.expectedHash, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransplantCommitsIntoBranchRequest struct {
	ctx context.Context
	ApiService *V1APIService
	branchName string
	expectedHash *string
	transplant1 *Transplant1
	message *string
}

// Expected hash of tag.
func (r ApiTransplantCommitsIntoBranchRequest) ExpectedHash(expectedHash string) ApiTransplantCommitsIntoBranchRequest {
	r.expectedHash = &expectedHash
	return r
}

// Hashes to transplant
func (r ApiTransplantCommitsIntoBranchRequest) Transplant1(transplant1 Transplant1) ApiTransplantCommitsIntoBranchRequest {
	r.transplant1 = &transplant1
	return r
}

// commit message
func (r ApiTransplantCommitsIntoBranchRequest) Message(message string) ApiTransplantCommitsIntoBranchRequest {
	r.message = &message
	return r
}

func (r ApiTransplantCommitsIntoBranchRequest) Execute() (*MergeResponse, *http.Response, error) {
	return r.ApiService.TransplantCommitsIntoBranchExecute(r)
}

/*
TransplantCommitsIntoBranch Transplant commits from 'transplant' onto 'branchName'

This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param branchName Branch to transplant into
 @return ApiTransplantCommitsIntoBranchRequest
*/
func (a *V1APIService) TransplantCommitsIntoBranch(ctx context.Context, branchName string) ApiTransplantCommitsIntoBranchRequest {
	return ApiTransplantCommitsIntoBranchRequest{
		ApiService: a,
		ctx: ctx,
		branchName: branchName,
	}
}

// Execute executes the request
//  @return MergeResponse
func (a *V1APIService) TransplantCommitsIntoBranchExecute(r ApiTransplantCommitsIntoBranchRequest) (*MergeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.TransplantCommitsIntoBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trees/branch/{branchName}/transplant"
	localVarPath = strings.Replace(localVarPath, "{"+"branchName"+"}", url.PathEscape(parameterValueToString(r.branchName, "branchName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.expectedHash == nil {
		return localVarReturnValue, nil, reportError("expectedHash is required and must be specified")
	}
	if r.transplant1 == nil {
		return localVarReturnValue, nil, reportError("transplant1 is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "expectedHash", r.expectedHash, "form", "")
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transplant1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePropertiesRequest struct {
	ctx context.Context
	ApiService *V1APIService
	name Content1AnyOf2
	ref string
	updatePropertiesRequest *UpdatePropertiesRequest
	hashOnRef *string
}

// Namespace properties to update/delete.
func (r ApiUpdatePropertiesRequest) UpdatePropertiesRequest(updatePropertiesRequest UpdatePropertiesRequest) ApiUpdatePropertiesRequest {
	r.updatePropertiesRequest = &updatePropertiesRequest
	return r
}

// a particular hash on the given ref
func (r ApiUpdatePropertiesRequest) HashOnRef(hashOnRef string) ApiUpdatePropertiesRequest {
	r.hashOnRef = &hashOnRef
	return r
}

func (r ApiUpdatePropertiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePropertiesExecute(r)
}

/*
UpdateProperties Method for UpdateProperties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the name of the namespace
 @param ref name of ref to fetch
 @return ApiUpdatePropertiesRequest
*/
func (a *V1APIService) UpdateProperties(ctx context.Context, name Content1AnyOf2, ref string) ApiUpdatePropertiesRequest {
	return ApiUpdatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		ref: ref,
	}
}

// Execute executes the request
func (a *V1APIService) UpdatePropertiesExecute(r ApiUpdatePropertiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UpdateProperties")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/namespaces/namespace/{ref}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ref"+"}", url.PathEscape(parameterValueToString(r.ref, "ref")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePropertiesRequest == nil {
		return nil, reportError("updatePropertiesRequest is required and must be specified")
	}

	if r.hashOnRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hashOnRef", r.hashOnRef, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePropertiesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
