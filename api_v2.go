/*
Nessie API

Transactional Catalog for Data Lakes  * Git-inspired data version control * Cross-table transactions and visibility * Works with Apache Iceberg tables

API version: 0.102.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// V2APIService V2API service
type V2APIService service

type ApiCreateReferenceV2Request struct {
	ctx context.Context
	ApiService *V2APIService
	name *string
	type_ *string
	reference3 *Reference3
}

// A reference name.  Reference name must start with a letter, followed by letters, digits, one of the ./_- characters, not end with a slash or dot, not contain &#39;..&#39; 
func (r ApiCreateReferenceV2Request) Name(name string) ApiCreateReferenceV2Request {
	r.name = &name
	return r
}

// Type of the reference to be created
func (r ApiCreateReferenceV2Request) Type_(type_ string) ApiCreateReferenceV2Request {
	r.type_ = &type_
	return r
}

// Source reference data from which the new reference is to be created.
func (r ApiCreateReferenceV2Request) Reference3(reference3 Reference3) ApiCreateReferenceV2Request {
	r.reference3 = &reference3
	return r
}

func (r ApiCreateReferenceV2Request) Execute() (*SingleReferenceResponse1, *http.Response, error) {
	return r.ApiService.CreateReferenceV2Execute(r)
}

/*
CreateReferenceV2 Create a new branch or tag

The name and type query parameters define the kind of reference to be created. The payload object defines the new reference's origin in the commit history. 
Only branches and tags can be created by this method, but the payload object may be any valid reference, including a detached commit.
If the payload reference object does not define a commit hash, the HEAD of that reference will be used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReferenceV2Request
*/
func (a *V2APIService) CreateReferenceV2(ctx context.Context) ApiCreateReferenceV2Request {
	return ApiCreateReferenceV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleReferenceResponse1
func (a *V2APIService) CreateReferenceV2Execute(r ApiCreateReferenceV2Request) (*SingleReferenceResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleReferenceResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIService.CreateReferenceV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/trees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.reference3 == nil {
		return localVarReturnValue, nil, reportError("reference3 is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reference3
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllReferencesV2Request struct {
	ctx context.Context
	ApiService *V2APIService
	fetch *string
	filter *string
	maxRecords *int32
	pageToken *string
}

// Specifies how much extra information is to be retrived from the server.  If the fetch option is set to &#39;ALL&#39; the following addition information will be returned for each Branch object in the output:  - numCommitsAhead (number of commits ahead of the default branch)  - numCommitsBehind (number of commits behind the default branch)  - commitMetaOfHEAD (the commit metadata of the HEAD commit)  - commonAncestorHash (the hash of the common ancestor in relation to the default branch).  - numTotalCommits (the total number of commits from the root to the HEAD of the branch).  The returned Tag instances will only contain the &#39;commitMetaOfHEAD&#39; and &#39;numTotalCommits&#39; fields.  Note that computing &amp; fetching additional metadata might be computationally expensive on the server-side, so this flag should be used with care.
func (r ApiGetAllReferencesV2Request) Fetch(fetch string) ApiGetAllReferencesV2Request {
	r.fetch = &fetch
	return r
}

// A Common Expression Language (CEL) expression. An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md. Usable variables within the expression are:  - ref (Reference) describes the reference, with fields name (String), hash (String), metadata (ReferenceMetadata)  - metadata (ReferenceMetadata) shortcut to ref.metadata, never null, but possibly empty  - commit (CommitMeta) - shortcut to ref.metadata.commitMetaOfHEAD, never null, but possibly empty  - refType (String) - the reference type, either BRANCH or TAG  Note that the expression can only test attributes metadata and commit, if &#39;fetchOption&#39; is set to &#39;ALL&#39;.
func (r ApiGetAllReferencesV2Request) Filter(filter string) ApiGetAllReferencesV2Request {
	r.filter = &filter
	return r
}

// maximum number of entries to return, just a hint for the server
func (r ApiGetAllReferencesV2Request) MaxRecords(maxRecords int32) ApiGetAllReferencesV2Request {
	r.maxRecords = &maxRecords
	return r
}

// paging continuation token, as returned in the previous value of the field &#39;token&#39; in the corresponding &#39;EntriesResponse&#39; or &#39;LogResponse&#39; or &#39;ReferencesResponse&#39; or &#39;RefLogResponse&#39;.
func (r ApiGetAllReferencesV2Request) PageToken(pageToken string) ApiGetAllReferencesV2Request {
	r.pageToken = &pageToken
	return r
}

func (r ApiGetAllReferencesV2Request) Execute() (*GetAllReferencesV2200Response, *http.Response, error) {
	return r.ApiService.GetAllReferencesV2Execute(r)
}

/*
GetAllReferencesV2 Get information about all branches and tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllReferencesV2Request
*/
func (a *V2APIService) GetAllReferencesV2(ctx context.Context) ApiGetAllReferencesV2Request {
	return ApiGetAllReferencesV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllReferencesV2200Response
func (a *V2APIService) GetAllReferencesV2Execute(r ApiGetAllReferencesV2Request) (*GetAllReferencesV2200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllReferencesV2200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIService.GetAllReferencesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/trees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch", r.fetch, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.maxRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-records", r.maxRecords, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page-token", r.pageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
